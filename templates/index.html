<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>I2C Device Manager</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .device { border: 1px solid #ccc; padding: 10px; margin: 10px 0; }
        .config-form { margin-top: 10px; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <h1>I2C Device Manager</h1>
    
    <h2>Active Devices</h2>
    <div id="active-devices"></div>
    
    <h2>New Devices</h2>
    <div id="new-devices"></div>
    
    <h2>Archived Devices</h2>
    <div id="archived-devices"></div>

    <script>
        const socket = io();
        let config = { connections: [], new_connections: [], archived_connections: [] };
        let prevConfig = { connections: [], new_connections: [], archived_connections: [] };
        let pendingDataEvents = [];

        socket.on('connect', () => {
            console.log('Connected to server');
        });

        socket.on('config_update', (data) => {
            updateUI(data);
            prevConfig = JSON.parse(JSON.stringify(config));
            config = data;
            processPendingDataEvents();
        });

        socket.on('device_data', (data) => {
            console.log('Received device_data:', data);
            const deviceDiv = document.getElementById(`device-${data.address}`);
            if (!deviceDiv) {
                console.warn(`No device div found for address ${data.address}, queuing event`);
                pendingDataEvents.push(data);
                return;
            }
            handleDeviceData(data);
        });

        function processPendingDataEvents() {
            const remainingEvents = [];
            pendingDataEvents.forEach(data => {
                const deviceDiv = document.getElementById(`device-${data.address}`);
                if (deviceDiv) {
                    handleDeviceData(data);
                } else {
                    remainingEvents.push(data);
                }
            });
            pendingDataEvents = remainingEvents;
        }

        function handleDeviceData(data) {
            const deviceDiv = document.getElementById(`device-${data.address}`);
            const textElements = deviceDiv.querySelectorAll('.data-text');
            if (textElements.length === 0) {
                console.warn(`No text elements found for device ${data.address}`);
                return;
            }
            if (!data.data || typeof data.data !== 'object') {
                console.warn(`Invalid data structure for device ${data.address}:`, data.data);
                return;
            }
            const validKeys = getValidDataKeys(data.address);
            textElements.forEach(el => {
                if (el.dataset.key && validKeys.includes(el.dataset.key)) {
                    const value = data.data[el.dataset.key];
                    el.value = value !== undefined && value !== null ? value : 'N/A';
                    console.log(`Setting ${el.dataset.key} to ${el.value} for device ${data.address}`);
                } else {
                    console.warn(`Invalid or unknown data_key ${el.dataset.key} for device ${data.address}`);
                }
            });
        }

        function getValidDataKeys(address) {
            const conn = config.connections.find(c => c.address === address);
            if (!conn || !conn.ui_components) return [];
            return conn.ui_components
                .filter(ui => ui.type === 'text' && ui.data_key)
                .map(ui => ui.data_key);
        }

        function deepEqual(obj1, obj2) {
            if (obj1 === obj2) return true;
            if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 == null || obj2 == null) return false;
            let keys1 = Object.keys(obj1);
            let keys2 = Object.keys(obj2);
            if (keys1.length !== keys2.length) return false;
            for (let key of keys1) {
                if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) return false;
            }
            return true;
        }

        function updateUI(newConfig) {
            const activeDiv = document.getElementById('active-devices');
            const newDiv = document.getElementById('new-devices');
            const archivedDiv = document.getElementById('archived-devices');

            function updateSection(section, oldConns, newConns, container) {
                const oldMap = new Map(oldConns.map(conn => [conn.address, conn]));
                const newMap = new Map(newConns.map(conn => [conn.address, conn]));

                Array.from(container.children).forEach(child => {
                    const addr = child.id.replace('device-', '');
                    if (!newMap.has(addr)) {
                        child.remove();
                    }
                });

                newConns.forEach(newConn => {
                    const oldConn = oldMap.get(newConn.address);
                    const isActive = section === 'connections';
                    const deviceDiv = document.getElementById(`device-${newConn.address}`);

                    if (!oldConn || !deepEqual(oldConn, newConn)) {
                        const sliderValues = new Map();
                        if (deviceDiv && newConn.ui_components) {
                            newConn.ui_components.forEach(ui => {
                                if (ui.type === 'slider') {
                                    const slider = deviceDiv.querySelector(`input[data-channel="${ui.channel}"]`);
                                    if (slider) {
                                        sliderValues.set(ui.channel, slider.value);
                                    }
                                }
                            });
                        }

                        const newDiv = createDeviceDiv(newConn, isActive);
                        if (deviceDiv) {
                            container.replaceChild(newDiv, deviceDiv);
                        } else {
                            container.appendChild(newDiv);
                        }

                        if (newConn.ui_components) {
                            newConn.ui_components.forEach(ui => {
                                if (ui.type === 'slider' && sliderValues.has(ui.channel)) {
                                    const slider = newDiv.querySelector(`input[data-channel="${ui.channel}"]`);
                                    if (slider) {
                                        slider.value = sliderValues.get(ui.channel);
                                    }
                                }
                            });
                        }
                    }
                });
            }

            updateSection('connections', prevConfig.connections, newConfig.connections, activeDiv);
            updateSection('new_connections', prevConfig.new_connections, newConfig.new_connections, newDiv);
            updateSection('archived_connections', prevConfig.archived_connections, newConfig.archived_connections, archivedDiv);
        }

        function createDeviceDiv(conn, isActive) {
            const div = document.createElement('div');
            div.className = 'device';
            div.id = `device-${conn.address}`;
            div.innerHTML = `<h3>${conn.name} (${conn.address})</h3>`;
            
            if (isActive && conn.ui_components) {
                conn.ui_components.forEach(ui => {
                    if (ui.type === 'text') {
                        const textContainer = document.createElement('div');
                        const label = document.createElement('label');
                        label.textContent = `${ui.label}: `;
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'data-text';
                        input.dataset.key = ui.data_key;
                        input.readOnly = true;
                        textContainer.appendChild(label);
                        textContainer.appendChild(input);
                        textContainer.appendChild(document.createElement('br'));
                        div.appendChild(textContainer);
                    } else if (ui.type === 'slider') {
                        const sliderContainer = document.createElement('div');
                        const label = document.createElement('label');
                        label.textContent = `${ui.label}: `;
                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.min = ui.min;
                        slider.max = ui.max;
                        slider.value = ui.initial_value !== undefined ? ui.initial_value : 90;
                        slider.dataset.channel = ui.channel;
                        slider.oninput = () => {
                            const data = {
                                address: conn.address,
                                value: parseInt(slider.value),
                                channel: parseInt(ui.channel)
                            };
                            console.log(`Emitting write_device for channel ${ui.channel}:`, data);
                            socket.emit('write_device', data);
                        };
                        sliderContainer.appendChild(label);
                        sliderContainer.appendChild(slider);
                        sliderContainer.appendChild(document.createElement('br'));
                        div.appendChild(sliderContainer);
                    }
                });
            }

            const configBtn = document.createElement('button');
            configBtn.textContent = 'Configure';
            configBtn.onclick = () => showConfigForm(conn);
            div.appendChild(configBtn);

            return div;
        }

        function showConfigForm(conn) {
            const form = document.createElement('div');
            form.className = 'config-form';
            const hasReadInterval = conn.read_interval !== undefined;
            const readIntervalStyle = hasReadInterval ? '' : 'class="hidden"';
            form.innerHTML = `
                <p>Address: ${conn.address}</p>
                <label>Name: <input type="text" id="name" value="${conn.name}"></label><br>
                <label>Interface Module: <input type="text" id="interface_module" value="${conn.interface_module || ''}"></label><br>
                <label>Interface Class: <input type="text" id="interface_class" value="${conn.interface_class || ''}"></label><br>
                <label>UI Components (JSON): <textarea id="ui_components">${JSON.stringify(conn.ui_components || [], null, 2)}</textarea></label><br>
                <label ${readIntervalStyle} id="read_interval_label">Read Interval (seconds): <input type="number" id="read_interval" step="0.1" min="0" value="${conn.read_interval || 0.1}"></label><br>
                <button onclick="saveConfig('${conn.address}')">Save</button>
            `;
            document.body.appendChild(form);

            // Dynamically show/hide read_interval based on interface_module
            const interfaceModuleInput = document.getElementById('interface_module');
            const readIntervalLabel = document.getElementById('read_interval_label');
            interfaceModuleInput.addEventListener('input', () => {
                const module = interfaceModuleInput.value;
                const existingConn = [
                    ...config.connections,
                    ...config.new_connections,
                    ...config.archived_connections
                ].find(c => c.interface_module === module);
                if (existingConn && existingConn.read_interval !== undefined) {
                    readIntervalLabel.classList.remove('hidden');
                    document.getElementById('read_interval').value = existingConn.read_interval || 0.1;
                } else {
                    readIntervalLabel.classList.add('hidden');
                }
            });
        }

        function saveConfig(address) {
            const updatedConn = {
                address,
                name: document.getElementById('name').value,
                interface_module: document.getElementById('interface_module').value,
                interface_class: document.getElementById('interface_class').value,
                ui_components: JSON.parse(document.getElementById('ui_components').value || '[]'),
                active: config.connections.some(c => c.address === address) ? 1 : 0
            };

            // Include read_interval only if the field is visible
            const readIntervalLabel = document.getElementById('read_interval_label');
            if (!readIntervalLabel.classList.contains('hidden')) {
                const readInterval = parseFloat(document.getElementById('read_interval').value);
                if (!isNaN(readInterval) && readInterval >= 0) {
                    updatedConn.read_interval = readInterval;
                }
            }

            let section = 'connections';
            if (config.new_connections.some(c => c.address === address)) {
                section = 'new_connections';
                updatedConn.active = 1;
            } else if (config.archived_connections.some(c => c.address === address)) {
                section = 'archived_connections';
            }

            const index = config[section].findIndex(c => c.address === address);
            if (index !== -1) {
                config[section][index] = updatedConn;
                if (section === 'new_connections') {
                    config.connections.push(updatedConn);
                    config.new_connections.splice(index, 1);
                }
            }

            socket.emit('update_config', config);
            document.querySelector('.config-form').remove();
        }
    </script>
</body>
</html>
